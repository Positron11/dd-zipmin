#!/usr/bin/env python3

from __future__ import annotations

from pathlib import Path
from defusedxml import ElementTree as ET
import subprocess
import argparse
import importlib
import sys
import tempfile
import shutil


def build_oracle(base:Path, input_name:str, script_name:str, timeout:float|None):
	"""Generate XML oracle callable for debugger."""

	xml_path    = base / input_name
	script_path = base / script_name
	
	cache: dict[str, bool] = {}

	def oracle(candidate:str) -> bool:
		# memoize repeated candidates across iterations
		hit = cache.get(candidate)
		if hit is not None: return hit

		# fast well-formedness pre-check
		try: ET.fromstring(candidate)
		
		except Exception: 
			cache[candidate] = False
			return False

		tmp_path = xml_path.with_suffix(xml_path.suffix + ".tmp")
		
		# write candidate to file
		tmp_path.write_text(candidate, encoding="utf-8", errors="ignore")
		tmp_path.replace(xml_path)
		
		try:
			proc = subprocess.run(["bash", script_path.name],
				cwd    =str(base),
				stdout =subprocess.DEVNULL,
				stderr =subprocess.DEVNULL,
				timeout=timeout,
				check  =False
			)

		# false on timeout
		except subprocess.TimeoutExpired:
			cache[candidate] = False
			return False

		# ok if desired error (retcode=0)
		ok = proc.returncode == 0
		
		# cache candidate retcode
		cache[candidate] = ok
		return ok

	return oracle


def main(verbose=False):
	p = argparse.ArgumentParser(description=__doc__)
	
	p.add_argument(
		"predicate_dir",
		type=Path,
		help="Path to xmlprocessor predicate directory (contains r.sh and input.xml)",
	)

	p.add_argument(
		"--module",
		default="dd.ddmin",
		help="Python module with minimize(target, oracle, verbose) (default: dd.ddmin)",
	)
	
	p.add_argument(
		"--input",
		default="input.xml",
		help="Input filename within the predicate directory (default: input.xml)",
	)
	
	p.add_argument(
		"--script",
		default="r.sh",
		help="Predicate runner script within the directory (default: r.sh)",
	)
	
	p.add_argument(
		"--timeout",
		type=float,
		default=60.0,
		help="Per-oracle timeout in seconds (default: 60)",
	)

	p.add_argument(
		"--ramdisk",
		action="store_true",
		help="Run predicate from a copy under /dev/shm (tmpfs) for faster I/O",
	)

	p.add_argument(
		"--ram-root",
		default="/dev/shm",
		help="Root directory of tmpfs to use with --ramdisk (default: /dev/shm)",
		)
	
	p.add_argument(
		"--in-place",
		action="store_true",
		help="Overwrite the input file with the minimized result (default: write to input.min.xml)",
	)
	
	p.add_argument(
		"--output",
		default="input.min.xml",
		help="Output filename for minimized result (default: input.min.xml)",
	)
	
	args = p.parse_args()

	# construct paths
	base_path = args.predicate_dir.resolve()
	xml_path  = base_path / args.input

	# argument value errors
	if not xml_path.exists(): p.error(f"Input file not found: {xml_path}")
	if not (base_path / args.script).exists(): p.error(f"Oracle script not found: {base_path / args.script}")

	run_base   = base_path
	tmp_parent = None
	
	# optimization: run from a RAM-disk copy under /dev/shm
	if args.ramdisk:
		ram_root = Path(args.ram_root)
	
		# cannot resolve RAM-disk path
		if not ram_root.exists() or not ram_root.is_dir():
			print(f"Warning: ram-root {ram_root} not available; running in-place", file=sys.stderr)
	
		else:
			tmp_parent = tempfile.mkdtemp(prefix="ddmin-", dir=str(ram_root))
			run_base   = Path(tmp_parent) / base_path.name
			lib_path   = base_path.parent / "lib"
			ram_lib    = Path(tmp_parent) / "lib"
			
			# copy predicate and lib dirs to RAM-disk
			shutil.copytree(base_path, run_base)
			shutil.copytree(lib_path, ram_lib)

	# read input.xml to string
	original = xml_path.read_text(encoding="utf-8")
	
	oracle = build_oracle(run_base, args.input, args.script, args.timeout)

	try:
		# dynamically import the minimizer module and fetch its minimize()
		dd_variant = importlib.import_module(args.module)
		minimize   = getattr(dd_variant, "minimize")
	
	except Exception as e: p.error(f"Failed to import minimize from module '{args.module}': {e}")

	minimized = None

	try:
		minimized, n_oracle_calls = minimize(
			target =original, 
			oracle =oracle,
			stats  =True,
			verbose=verbose
		)

		# update input.xml in-place
		if args.in_place: out_path = xml_path
			
		else:
			out_path = base_path / args.output
			
			# prevent accidental overwrite when not using --in-place
			if out_path.resolve() == xml_path.resolve():
				p.error("--output cannot equal input file; use --in-place to overwrite")

		out_path.write_text(minimized, encoding="utf-8")

		# success log
		if verbose:
			print(f"\nMinimized length: {len(minimized)}")
			print(f"Oracle invocations: {n_oracle_calls}")
			print(f"Wrote: {out_path}")

	# handle keyboard interrupts
	except KeyboardInterrupt:
		print("\nInterrupted by user. Cleaning up...", file=sys.stderr)
		sys.exit(130)

	finally:
		# restore original input.xml content
		if not (minimized and args.in_place): xml_path.write_text(original, encoding="utf-8")

		# cleanup RAM-disk copy if used
		if tmp_parent is not None:
			try: shutil.rmtree(tmp_parent)
			except Exception as e:
				print(f"Warning: failed to clean ramdisk dir {tmp_parent}: {e}", file=sys.stderr)
	

if __name__ == "__main__":
	main(verbose=True)
