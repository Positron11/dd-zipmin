#!/usr/bin/env python3

from pathlib import Path
import argparse
import sys
import os
import random
from dataclasses import dataclass
from typing import Callable, Dict, List, Tuple
from defusedxml import ElementTree as ET

from utils.oracle import build_oracle
from utils.ramdisk import RamDir, RamdiskUnavailable


@dataclass
class NodeInfo:
	node:ET.Element
	parent:ET.Element|None
	depth:int
	index:int  # index among parent's children


def iter_nodes_with_parents(root:ET.Element) -> List[NodeInfo]:
	"""Breadth-first traversal capturing parent and depth for all elements."""

	out: List[NodeInfo] = []
	queue: List[Tuple[ET.Element, ET.Element | None, int]] = [(root, None, 0)]

	while queue:
		node, parent, depth = queue.pop(0)
		
		idx = -1
		
		# compute index among parent's children (0-based)
		if parent is not None:
			for i, ch in enumerate(list(parent)):
				if ch is node:
					idx = i
					break

		out.append(NodeInfo(node=node, parent=parent, depth=depth, index=idx))
		
		for ch in list(node):
			queue.append((ch, node, depth + 1))

	return out


def node_path(info:NodeInfo) -> str:
	"""Construct a simple path like /a[1]/b[3]/c[2]."""

	# build up via parent pointers (we don't retain the full map, rebuild minimal)
	segs:List[str]      = []
	cur:ET.Element|None = info.node
	
	while cur is not None:
		parent = None
		idx    = 0
		
		if segs:
			# we are climbing; need to discover parent and index for current
			# this is best-effort: walk siblings from known parent in segment list.
			# for simplicity, we skip exact re-computation and just mark '?' for non-leaf.
			segs.append("?")
			break
		
		# for the leaf, we can report its position among siblings by tag
		if info.parent is not None:
			siblings = [c for c in list(info.parent) if c.tag == info.node.tag]
			
			try: idx = siblings.index(info.node) + 1
			except ValueError: idx = info.index + 1 if info.index >= 0 else 1
		
		else: idx = 1

		tag = str(cur.tag)
		segs.append(f"{tag}[{idx}]")
		cur = None if info.parent is None else info.parent

	return "/" + "/".join(reversed(segs))


def serialize(root:ET.Element) -> str:
	return ET.tostring(root, encoding="unicode")


def bytes_len(s:str) -> int:
	return len(s.encode("utf-8", errors="ignore"))


def pick_depth(depths:List[int], rng:random.Random) -> int:
	"""Pick a target depth with a bias towards shallower nodes (larger blocks)."""
	
	if not depths: return 0
	
	dmin, dmax = min(depths), max(depths)
	
	if dmax <= 1: return dmin
	
	cutoff = (dmin + dmax) // 2
	
	# 75% choose from shallower half, 25% from deeper half
	if rng.random() < 0.75:
		cands = [d for d in depths if d <= cutoff]
		return rng.choice(cands) if cands else rng.choice(depths)
	
	else:
		cands = [d for d in depths if d > cutoff]
		return rng.choice(cands) if cands else rng.choice(depths)


def cherry_pick(
	original:str,
	oracle:Callable[[str], bool],
	min_bytes:int,
	max_bytes:int,
	seed:int|None,
	verbose:bool,
	max_attempts:int) -> Tuple[str, int, int, int]:
	
	"""Randomly remove element subtrees while preserving oracle==True and bounds."""

	rng = random.Random(seed)

	try:root = ET.fromstring(original)
	except Exception as e: raise SystemExit(f"Input is not well-formed XML: {e}")

	doc  = serialize(root)
	size = bytes_len(doc)

	n_calls  = 0
	n_accept = 0
	n_reject = 0

	if verbose:
		print(f"Start size: {size} bytes | Target: [{min_bytes}, {max_bytes}] bytes")

	# early exit if already within bounds and oracle holds
	if min_bytes <= size <= max_bytes:
		ok = oracle(doc)
		
		n_calls += 1
		
		if ok:
			if verbose: print("Already within bounds and oracle ok; no changes.")
			return doc, n_calls, n_accept, n_reject

	# if oracle doesn't hold initially, abort: cannot shrink towards a failing base
	ok0 = oracle(doc)
	n_calls += 1
	
	if not ok0: raise SystemExit("Initial input does not satisfy oracle (exit 0). Aborting cherry-pick.")

	# keep trying removals
	attempts            = 0
	stagnation          = 0
	last_accept_attempt = -1

	while attempts < max_attempts:
		attempts += 1
		
		nodes = iter_nodes_with_parents(root)

		# can't remove the root; filter candidates to elements with a parent
		candidates = [ni for ni in nodes if ni.parent is not None]
		
		if not candidates:
			if verbose: print("No removable nodes left. Stopping.")
			break

		depths       = [ni.depth for ni in candidates]
		target_depth = pick_depth(depths, rng)
		depth_pool   = [ni for ni in candidates if ni.depth == target_depth]
		pool         = depth_pool if depth_pool else candidates
		
		# prefer larger subtrees: sample a few from the pool and pick largest
		if pool:
			sample_k = min(8, len(pool))
			sample   = rng.sample(pool, k=sample_k)
		
			# measure approximate subtree size
			best_info = None
			best_size = -1
			
			for ni in sample:
				try: sz = bytes_len(ET.tostring(ni.node, encoding="unicode"))
				except Exception: sz = -1
				
				if sz > best_size:
					best_size = sz
					best_info = ni
			
			info = best_info if best_info is not None else rng.choice(pool)
		
		else: info = rng.choice(candidates)

		# measure subtree size and some stats
		subtree_str   = ET.tostring(info.node, encoding="unicode")
		subtree_bytes = bytes_len(subtree_str)
		before_size   = bytes_len(serialize(root))

		tag        = str(info.node.tag)
		n_attrs    = len(info.node.attrib)
		n_children = len(list(info.node))
		path       = node_path(info)

		# propose removal
		parent = info.parent
		
		try: parent.remove(info.node)
		except Exception as e:
			n_reject += 1
		
			if verbose: print(
					f"try {attempts:04d} | depth {info.depth} | node {tag} | "
					f"subtree ~{subtree_bytes} B | ERROR removing node: {e}"
				)
			
			continue

		# serialize candidate and evaluate
		candidate = serialize(root)
		after_size = bytes_len(candidate)

		# never shrink below min bound
		if after_size < min_bytes:
			# revert
			parent.insert(info.index if info.index >= 0 else 0, info.node)
		   
			n_reject += 1
		   
			if verbose:
				print(
					f"try {attempts:04d} | size {before_size}->{after_size} B | "
					f"depth {info.depth} | node {tag} {path} | attrs {n_attrs} | "
					f"kids {n_children} | subtree ~{subtree_bytes} B | "
					f"REJECT: would drop below min ({min_bytes} B)"
				)
		   
			stagnation += 1
		   
			if stagnation > 200 and (attempts - last_accept_attempt) > 200:
				if verbose: print("Stagnating (size floor). Stopping.")
				break
			
			continue

		ok = oracle(candidate)
		
		n_calls += 1

		if ok:
			# accept change
			n_accept += 1
			
			last_accept_attempt = attempts
			size                = after_size
			
			if verbose:
				print(
					f"try {attempts:04d} | size {before_size}->{after_size} B | "
					f"depth {info.depth} | node {tag} {path} | attrs {n_attrs} | "
					f"kids {n_children} | subtree ~{subtree_bytes} B | ACCEPT"
				)

			# if within bounds, stop
			if min_bytes <= size <= max_bytes:
				if verbose: print("Reached target bounds.")
				doc = candidate
				break

			# continue search from the new tree
			doc        = candidate
			stagnation = 0

		else:
			# revert the removal
			parent.insert(info.index if info.index >= 0 else 0, info.node)
			
			n_reject += 1
			
			stagnation += 1
			
			if verbose:
				print(
					f"try {attempts:04d} | size {before_size}->{after_size} B | "
					f"depth {info.depth} | node {tag} {path} | attrs {n_attrs} | "
					f"kids {n_children} | subtree ~{subtree_bytes} B | REJECT: oracle"
				)

			# if too many consecutive rejects, reshuffle bias by random jitter
			if stagnation % 50 == 0 and verbose: print("No progress recently; continuing with new random choices...")

	else:
		if verbose: print("Max attempts reached.")

	return serialize(root), n_calls, n_accept, n_reject


def main():
	p = argparse.ArgumentParser(
		description=(
			"Randomly remove XML element subtrees while preserving oracle==0 and "
			"keeping size within bounds."
		)
	)

	p.add_argument(
		"predicate_dir",
		type=Path,
		help="Path to xmlprocessor predicate directory (contains r.sh and input.xml)",
	)

	p.add_argument(
		"--input",
		default="input.xml",
		help="Input filename within the predicate directory (default: input.xml)",
	)

	p.add_argument(
		"--script",
		default="r.sh",
		help="Predicate runner script within the directory (default: r.sh)",
	)

	p.add_argument(
		"--good-port",
		default=os.environ.get("BASEX_GOOD_PORT", "1984"),
		help="Port on which good BaseXServer is running (env BASEX_GOOD_PORT overrides; default: 1984)",
	)

	p.add_argument(
		"--timeout",
		type=float,
		default=60.0,
		help="Per-oracle timeout in seconds (default: 60)",
	)

	p.add_argument(
		"--ramdisk",
		action="store_true",
		help="Run predicate from a copy under /dev/shm (tmpfs) for faster I/O",
	)

	p.add_argument(
		"--ram-root",
		type=Path,
		default="/dev/shm",
		help="Root directory of tmpfs to use with --ramdisk (default: /dev/shm)",
	)

	p.add_argument(
		"--output",
		default="input.pick.xml",
		help="Output filename for result (default: input.pick.xml)",
	)

	p.add_argument(
		"--min-kb",
		type=int,
		default=5,
		help="Lower bound target size in kilobytes (default: 5)",
	)

	p.add_argument(
		"--max-kb",
		type=int,
		default=10,
		help="Upper bound target size in kilobytes (default: 10)",
	)

	p.add_argument(
		"--seed",
		type=int,
		default=None,
		help="Random seed for reproducibility (default: None)",
	)

	p.add_argument(
		"--max-attempts",
		type=int,
		default=100000,
		help="Max node removal attempts to try (default: 100000)",
	)

	p.add_argument(
		"--verbose",
		action="store_true",
		help="Print detailed logs",
	)

	args = p.parse_args()

	# construct paths
	base_path = args.predicate_dir.resolve()
	xml_path = base_path / args.input

	# argument value errors
	if not xml_path.exists(): p.error(f"Input file not found: {xml_path}")
	if not (base_path / args.script).exists(): p.error(f"Oracle script not found: {base_path / args.script}")

	run_base = base_path
	ramdir   = None
	
	# optimization: run from a RAM-disk copy under /dev/shm
	if args.ramdisk:
		try: 
			ramdir = RamDir("cherrypk", args.ram_root)

			ramdir.copy([
				(base_path, base_path.name), 
				(base_path.parent / "lib", "lib"), 
				(base_path.parent / "shared", "shared")
			])

			run_base = ramdir.ram_dir / base_path.name
		
		except RamdiskUnavailable as e: print(f"Warning: {e}; running in-place", file=sys.stderr)

	# read input.xml to string
	original = xml_path.read_text(encoding="utf-8")

	oracle = build_oracle(
		base       =run_base, 
		input_name =args.input, 
		script_name=args.script, 
		good_port  =args.good_port,
		timeout    =args.timeout
	)

	min_bytes = max(0, int(args.min_kb) * 1024)
	max_bytes = max(0, int(args.max_kb) * 1024)
	
	if min_bytes > max_bytes: p.error("--min-kb must be <= --max-kb")

	try:
		result, n_calls, n_accept, n_reject = cherry_pick(
			original    =original,
			oracle      =oracle,
			min_bytes   =min_bytes,
			max_bytes   =max_bytes,
			seed        =args.seed,
			verbose     =args.verbose,
			max_attempts=args.max_attempts,
		)

		out_path = base_path / args.output
		out_path.write_text(result, encoding="utf-8")

		# success log
		if args.verbose:
			print("\nSummary:")
			print(f" - Final size: {bytes_len(result)} bytes")
			print(f" - Oracle calls: {n_calls}")
			print(f" - Accepts: {n_accept}")
			print(f" - Rejects: {n_reject}")
			print(f" - Wrote: {out_path}")

	# handle keyboard interrupts
	except KeyboardInterrupt:
		print("\nInterrupted by user (130)", file=sys.stderr)
		sys.exit(130)
	
	finally:
		print("\nCleaning up...")
		
		# restore original input.xml content
		if not args.ramdisk: 
			print(f" - Restoring original input ({xml_path})...")
			xml_path.write_text(original, encoding="utf-8")

		# cleanup RAM-disk copy if used
		if ramdir is not None:
			print(f" - Clearing RAM disk ({ramdir})...")
			ramdir.clean()

		print(" - Done.")


if __name__ == "__main__":
	main()
