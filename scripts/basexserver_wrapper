#!/usr/bin/env bash
set -Eeuo pipefail

print_usage() {
	printf >&2 "Usage: basexserver_wrapper [-h|--help] -- <subcommand> [args...]

Options:
	-h, --help         Show this help and exit

Behavior:
	- Scans the subcommand args for a directory containing v.sh (predicate dir).
	- Reads GOOD_VERSION/BAD_VERSION from that v.sh.
	- Scans from port 1984 for the next two free contiguous ports.
	- Starts BaseX servers (bad=good+1), sets BASEX_GOOD_PORT in env, runs subcommand.
	- Cleans up servers on exit.

Example:
	basexserver_wrapper -- scripts/minimize_xml --ramdisk --verbose predicates/xmlprocessor/xml-f053486-2\n"
}

SCRIPT_DIR="$(cd -- "$(dirname -- "$0")" >/dev/null 2>&1 && pwd)"

HOST=127.0.0.1
PASS=password

# parse args: only -h/--help allowed before --
ARGS=("$@")
VSH_DIR=""
sep_index=-1

for i in "${!ARGS[@]}"; do
	case "${ARGS[i]}" in
		-h|--help) print_usage; exit 0 ;;
		
		--) sep_index=$i; break ;;
		
		*)
			echo "Unknown option: $1" >&2
			print_usage
			exit 2 ;;
	esac
done

# validate separator + subcommand
if (( sep_index < 0 )); then
	echo "Missing '--' separator between wrapper and subcommand" >&2
	print_usage; exit 2
elif (( sep_index == ${#ARGS[@]}-1 )); then
	echo "Missing subcommand after '--'" >&2
	print_usage; exit 2
fi

# everything after "--" = subcommand args
SUBCMD_ARGS=("${ARGS[@]:sep_index+1}")

# scan backward for predicate dir with v.sh
for (( i=${#SUBCMD_ARGS[@]}-1; i>=0; i-- )); do
	if [[ -d ${SUBCMD_ARGS[i]} && -f ${SUBCMD_ARGS[i]}/v.sh ]]; then
		VSH_DIR=$(cd "${SUBCMD_ARGS[i]}" && pwd -P)
		break
	fi
done

if [[ -z "$VSH_DIR" ]]; then
	echo "Could not find predicate directory containing v.sh in subcommand args" >&2
	exit 2
fi

LIB_DIR="$VSH_DIR/../lib"

# extract versions from v.sh
source "$VSH_DIR/v.sh"

if [[ -z "${GOOD_VERSION:-}" || -z "${BAD_VERSION:-}" ]]; then
  echo "Could not parse GOOD_VERSION/BAD_VERSION from $VSH_DIR/v.sh" >&2; exit 1
fi

JAR_GOOD="$LIB_DIR/basex-$GOOD_VERSION.jar"
JAR_BAD="$LIB_DIR/basex-$BAD_VERSION.jar"

for j in "$JAR_GOOD" "$JAR_BAD"; do
	[[ -f "$j" ]] || { echo "Missing jar: $j" >&2; exit 1; }
done

# helpers
port_in_use() {
	local port="$1"
	nc -z "$HOST" "$port" 2>/dev/null
}

find_free_pair() {
	local start=${1:-1984}
	local p=$start
	
	while [[ $p -lt 65535 ]]; do
		local p2=$((p+1))
		
		if ! port_in_use "$p" && ! port_in_use "$p2"; then
			echo "$p $p2"
			return 0
		fi
		
		p=$((p+1))
	done
	
	return 1
}

wait_for_port() {
	local host="$1" port="$2" timeout="${3:-20}"
	
	for ((i=0; i<timeout*10; i++)); do
		if port_in_use "$port"; then return 0; fi
		sleep 0.1
	done
	
	echo "Timeout waiting for $host:$port" >&2; return 1
}

read GOOD_PORT BAD_PORT < <(find_free_pair 1990) || { echo "Failed to find two free contiguous ports" >&2; exit 1; }

good_pid=""; 
bad_pid=""

cleanup() {
	local ec=$?

	trap - EXIT INT TERM

	[[ -n "${good_pid:-}" ]] && { kill "$good_pid" 2>/dev/null || true; wait "$good_pid" 2>/dev/null || true; }
	[[ -n "${bad_pid:-}"  ]] && { kill "$bad_pid"  2>/dev/null || true; wait "$bad_pid"  2>/dev/null || true; }

	exit "$ec"
}

trap cleanup EXIT INT TERM

echo "Starting BaseX servers for $VSH_DIR/v.sh"
echo " - good: $JAR_GOOD : $HOST:$GOOD_PORT"
echo " - bad:  $JAR_BAD : $HOST:$BAD_PORT"

# start servers
java -cp "$JAR_BAD"  org.basex.BaseXServer -n "$HOST" -p "$BAD_PORT"  -c "PASSWORD $PASS" > /dev/null 2>&1 & bad_pid=$!
java -cp "$JAR_GOOD" org.basex.BaseXServer -n "$HOST" -p "$GOOD_PORT" -c "PASSWORD $PASS" > /dev/null 2>&1 & good_pid=$!

# wait for readiness
wait_for_port "$HOST" "$BAD_PORT" 25
wait_for_port "$HOST" "$GOOD_PORT" 25

echo -e "\n--- subcommand:\n"

# run subcommand exactly as provided, appending --good-port properly
"${SUBCMD_ARGS[@]}" --good-port "$GOOD_PORT"
